#BlueJ class context
comment0.params=
comment0.target=RingBufferTest()
comment0.text=\r\n\ Default\ constructor\ for\ test\ class\ RingBufferTest\r\n
comment1.params=
comment1.target=void\ setUp()
comment1.text=\r\n\ Sets\ up\ the\ test\ fixture.\r\n\r\n\ Called\ before\ every\ test\ case\ method.\r\n
comment2.params=
comment2.target=void\ test1()
comment2.text=\r\n\ Test1\ \r\n\ Die\ zu\ Beginn\ sollten\ keine\ Elemente\ in\ dem\ gerade\ erzeugten\ Ringbuffer\ drin\ sein\r\n
comment3.params=
comment3.target=void\ test2()
comment3.text=\r\n\ Test2\ \r\n\ F\u00C3\u00BCgt\ ein\ Element\ dem\ Ringbuffer\ hinzu\ und\ \u00C3\u00BCberpr\u00C3\u00BCft\ dann\ die\ Gr\u00C3\u00B6\u00C3\u0178e\ des\ Ringbuffers.\ Diese\ sollte\ nun\ 1.\r\n
comment4.params=
comment4.target=void\ test3()
comment4.text=\r\n\ Test3\r\n\ F\u00C3\u00BCgt\ ein\ neues\ Element\ dem\ Ringbuffer\ hinzu.\ \r\n\ Da\ der\ Ringbuffer\ gerade\ erzuegt\ wurde\ ist\ dieses\ zugleich\ auch\ das\ \u00C3\u00A4lteste\ Ele\ \ ment\ und\ wird\ mittels\ ring.pop()\ entnommen.\r\n
comment5.params=
comment5.target=void\ test4()
comment5.text=\r\n\ Test4\ \r\n\ F\u00C3\u00BCllt\ den\ Ringbuffer\ mit\ Zahlen\ in\ aufsteigender\ Reihenfolge.\r\n\ Danach\ wird\ einmal\ die\ toString\ Methode\ bei\ der\ Ausgabe\ in\ der\ Konsole\ getestet\ (\ nicht\ automatisiert)\r\n\ und\ es\ wird\ geschaut\ ob\ das\ \u00C3\u00A4lteste\ Element\ 0\ ist\ (\ da\ die\ 0\ als\ erstes\ hinzugef\u00C3\u00BCgt\ wurde).\r\n
comment6.params=
comment6.target=void\ test5()
comment6.text=\r\n\ Test5\ \r\n\ F\u00C3\u00BCllt\ den\ Ringbuffer\ mit\ Zahlen\ in\ aufsteigender\ Reihenfolge\ und\ f\u00C3\u00BCgt\ danach\ noch\ "11"\ und\ "12"\ hinzu.\r\n\ Der\ Ringbuffer\ sollte\ jetzt\ immernoch\ die\ l\u00C3\u00A4nge\ laenge\ haben.\ \r\n
comment7.params=
comment7.target=void\ test6()
comment7.text=\r\n\ Test\ 6\r\n\ Diesmal\ wird\ ein\ Ringbuffer\ mit\ der\ L\u00C3\u00A4nge\ 25\ verwendet.\r\n\ Diesem\ Ringbuffer\ werden\ nacheinander\ alle\ Zahlen\ von\ 0\ bis\ 99\ hinzugef\u00C3\u00BCgt.\r\n\ Hier\ sollte\ der\ Ringbuffer\ "\u00C3\u00BCberlaufen"\ und\ nur\ noch\ die\ letzten\ 25\ Elemente\ enthalten.\r\n\ Dies\ wird\ in\ der\ zweiten\ for-Schleife\ auch\ \u00C3\u00BCberpr\u00C3\u00BCft,\ indem\ bei\ jedem\ Schleifendurchlauf\ geschaut\ wird,\ ob\ die\ L\u00C3\u00A4nge\ \r\n\ des\ Ringbuffers\ mit\ jedem\ Schleifendurchlauf\ abnimmt\ (\ man\ nutzt\ bei\ der\ 2ten\ Anweisung\ in\ der\ Schleife\ pop(),\ wodurch\ \r\n\ das\ Element\ aus\ der\ Schleife\ entfernt\ werden\ sollte)\ und\ \u00C3\u00BCberpr\u00C3\u00BCft\ ob\ tats\u00C3\u00A4chlich\ die\ 75\ bis\ einschlie\u00C3\u0178lich\ 99\ enth\u00C3\u00A4lt.\r\n\ \r\n\ Zus\u00C3\u00A4tzlich\ wird\ zwischen\ den\ beiden\ Schleifen\ die\ toString()\ Methode\ getestet.\ Au\u00C3\u0178erdem\ kann\ man\ so\ schauen\ ob\ tats\u00C3\u00A4chlich\ \r\n\ die\ Elemente\ im\ Ringbuffer\ sind,\ die\ da\ auch\ sein\ sollen.\r\n
comment8.params=
comment8.target=void\ tearDown()
comment8.text=\r\n\ Tears\ down\ the\ test\ fixture.\r\n\r\n\ Called\ after\ every\ test\ case\ method.\r\n
numComments=9
