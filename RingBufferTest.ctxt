#BlueJ class context
comment0.params=
comment0.target=RingBufferTest()
comment0.text=\n\ Default\ constructor\ for\ test\ class\ RingBufferTest\n
comment1.params=
comment1.target=void\ setUp()
comment1.text=\n\ Sets\ up\ the\ test\ fixture.\n\n\ Called\ before\ every\ test\ case\ method.\n
comment2.params=
comment2.target=void\ test1()
comment2.text=\n\ Test1\ \n\ Die\ zu\ Beginn\ sollten\ keine\ Elemente\ in\ dem\ gerade\ erzeugten\ Ringbuffer\ drin\ sein\n
comment3.params=
comment3.target=void\ test2()
comment3.text=\n\ Test2\ \n\ F\u00FCgt\ ein\ Element\ dem\ Ringbuffer\ hinzu\ und\ \u00FCberpr\u00FCft\ dann\ die\ Gr\u00F6\u00DFe\ des\ Ringbuffers.\ Diese\ sollte\ nun\ 1.\n
comment4.params=
comment4.target=void\ test3()
comment4.text=\n\ Test3\n\ F\u00FCgt\ ein\ neues\ Element\ dem\ Ringbuffer\ hinzu.\ \n\ Da\ der\ Ringbuffer\ gerade\ erzuegt\ wurde\ ist\ dieses\ zugleich\ auch\ das\ \u00E4lteste\ Ele\ \ ment\ und\ wird\ mittels\ ring.pop()\ entnommen.\n
comment5.params=
comment5.target=void\ test4()
comment5.text=\n\ Test4\ \n\ F\u00FCllt\ den\ Ringbuffer\ mit\ Zahlen\ in\ aufsteigender\ Reihenfolge.\n\ Danach\ wird\ einmal\ die\ toString\ Methode\ bei\ der\ Ausgabe\ in\ der\ Konsole\ getestet\ (\ nicht\ automatisiert)\n\ und\ es\ wird\ geschaut\ ob\ das\ \u00E4lteste\ Element\ 0\ ist\ (\ da\ die\ 0\ als\ erstes\ hinzugef\u00FCgt\ wurde).\n
comment6.params=
comment6.target=void\ test5()
comment6.text=\n\ Test5\ \n\ F\u00FCllt\ den\ Ringbuffer\ mit\ Zahlen\ in\ aufsteigender\ Reihenfolge\ und\ f\u00FCgt\ danach\ noch\ "11"\ und\ "12"\ hinzu.\n\ Der\ Ringbuffer\ sollte\ jetzt\ immernoch\ die\ l\u00E4nge\ laenge\ haben.\ \n
comment7.params=
comment7.target=void\ test6()
comment7.text=\n\ Test\ 6\n\ Diesmal\ wird\ ein\ Ringbuffer\ mit\ der\ L\u00E4nge\ 25\ verwendet.\n\ Diesem\ Ringbuffer\ werden\ nacheinander\ alle\ Zahlen\ von\ 0\ bis\ 99\ hinzugef\u00FCgt.\n\ Hier\ sollte\ der\ Ringbuffer\ "\u00FCberlaufen"\ und\ nur\ noch\ die\ letzten\ 25\ Elemente\ enthalten.\n\ Dies\ wird\ in\ der\ zweiten\ for-Schleife\ auch\ \u00FCberpr\u00FCft,\ indem\ bei\ jedem\ Schleifendurchlauf\ geschaut\ wird,\ ob\ die\ L\u00E4nge\ \n\ des\ Ringbuffers\ mit\ jedem\ Schleifendurchlauf\ abnimmt\ (\ man\ nutzt\ bei\ der\ 2ten\ Anweisung\ in\ der\ Schleife\ pop(),\ wodurch\ \n\ das\ Element\ aus\ der\ Schleife\ entfernt\ werden\ sollte)\ und\ \u00FCberpr\u00FCft\ ob\ tats\u00E4chlich\ die\ 75\ bis\ einschlie\u00DFlich\ 99\ enth\u00E4lt.\n\ \n\ Zus\u00E4tzlich\ wird\ zwischen\ den\ beiden\ Schleifen\ die\ toString()\ Methode\ getestet.\ Au\u00DFerdem\ kann\ man\ so\ schauen\ ob\ tats\u00E4chlich\ \n\ die\ Elemente\ im\ Ringbuffer\ sind,\ die\ da\ auch\ sein\ sollen.\n
comment8.params=
comment8.target=void\ tearDown()
comment8.text=\n\ Tears\ down\ the\ test\ fixture.\n\n\ Called\ after\ every\ test\ case\ method.\n
numComments=9
